think in java 复习   第四章 初始化和清除

java中构建器的采用了C++的思想   也就是采用 构建器名字和类名相同 且不允许有返回值  连void都不可以
如果一个方法是void 则不允许返回值   只允许使用return
方法重载: 方法的参数  个数  顺序不同  与返回值和访问修饰符无关

为什么不通过一个方法的返回值来 明确一个方法   因为如果编译器通过使用  int x =f() 但是如果我们调用一个方法 并不关心她的返回值
称为 对他的副作用去调用一个方法
为什么会存在函数重载   因为在现实中  吃可以表示很多概念   如吃饭   吃水果   如果用 人吃饭   水果吃水果  则会造成冗余
在程序设计中 也是  因此则产生了一个方法可以表示很多的动作  因此也就产生了函数重载的问题


this 关键字

class Banana { void f(int i) { /* ... */ } }
Banana a = new Banana(), b = new Banana();
a.f(1);
b.f(2);
若只有一个名叫f()的方法，它怎样才能知道自己是为a 还是为b 调用的呢？
为了能用简便的、面向对象的语法来书写代码——亦即“将消息发给对象”，编译器为我们完成了一些幕后
工作。其中的秘密就是第一个自变量传递给方法f()，而且那个自变量是准备操作的那个对象的句柄。所以
前述的两个方法调用就变成了下面这样的形式：
Banana.f(a,1);
Banana.f(b,2); a 和b  都是准备操作的那个对象的句柄

this 只能在方法内部使用 来引用调用对象的句柄
在方法内部来调用 另外的方法  通常不需要使用this关键字  因为方法会默认去找this的句柄  来调用相关的方法
假如您希望 
this通常用于那些特殊的类  需明确使用当前对象的句柄   假如你希望将句柄返回给当前对象 经常使用在return语句中

管可用this 调用一个构建器，
但不可调用两个。除此以外，构建器调用必须是我们做的第一件事情，否则会收到编译程序的报错信息。

/**
\我们不能从一个static方法内部 发出对非static方法的调用  这个观点是错误的   这句话是不能直接调用

但是可以 在静态方法内部  传给一个对象的句柄 然后通过这个句柄来调用   也就是通过一个对象来调用

有人抱怨static方法不是面向对象的  如果你写的类中有大量的static 方法  则应该考虑去改进他

       (1).对象不一定会被回收。
       (2).垃圾回收不是析构函数。
       (3).垃圾回收只与内存有关。
       (4).垃圾回收和finalize()都是靠不住的，只要JVM还没有快到耗尽内存的地步，它是不会浪费时间进行垃圾回收的。       
       通常java中创建的对象  是绝对会被垃圾回收期回收的，但是有特殊的情况 就是jni java本地接口调用了c或者c++的方法malloc 来分配内存
       
       这部分内存需要手动来回收,可以通过System.gc来通知 垃圾回收器 来回收垃圾  但是并不保证一定会被回收，一般如果jvm内存足够，那么他就可能
       
       永远不会执行,而等到程序结束的时候交给操作系统来处理,这一般是有效的,因为这样效率也更高
       
       java不允许创建局部对象  所有的对象都是用New来创建的
       
       变量在使用前必须初始化  因此在方法中的局部变量 必须初始化后才可以使用   而在类中的成员变量  系统会在构造的时候自动初始化
       
       详见构造器 构造顺序
       
       
       private String name；
       
       局部变量在使用前必须初始化  如果不初始化  编译器也可以做，但是这可能是程序员的错误
       
       因此编译器要求初始化前必须初始化  
       
       而成员变量  是一个类中 所有的方法都可以访问和修改的  因此如果要给所有的成员变量来赋一个固定初始值  这样显得不是很合理
       
       因此一般不要求初始化  而在类创建的时候   会默认赋一个初始值
       
       甚至可通过调用一个方法来提供初始值：int i=f();
       
       
       class CInit {
int i = f();
//...
}
当然，这个方法亦可使用自变量，但那些自变量不可是尚未初始化的其他类成员。因此，下面这样做是合法
的：
class CInit {
int i = f();
int j = g(i);
//...
}
但下面这样做是非法的：
class CInit {
int j = g(i);
int i = f();
//...
}



package com.thinkinjava;

class Father {
	static {
		System.out.println("父类静态代码块初始化");
	}
	{
		System.out.println("父类代码块初始化");
	}
	private static String s = print();

	public static String print() {
		System.out.println("父类静态方法");
		return "父类静态成员变量的初始化";
	}

	public Father() {
		System.out.println("父类无参构造函数初始化完成");
		show();
	}

	public void show() {
		System.out.println("父类show()方法");
	}
}

class Son extends Father {
	static {
		System.out.println("子类静态代码块初始化");
	}
	{
		System.out.println("子类代码块初始化");
	}
	private static int i = gene();
	private String s = ff();
	public  static int gene(){
		System.out.println("子类静态方法");
		return 2;
	}
	public String ff(){
		System.out.println("子类字段初始化");
		return "字段";
	}
	public void show() {
		System.out.println("子类show()方法：i=" + i);
	}

	public Son() {
		System.out.println("子类构造函数初始化完成");
		show();
	}
}

public class TestClassLoadSeq {
	public static void main(String[] args) {
		new Son();
	}

}运行上面的例子 就知道  代码块要比属性先初始化   顺序为  父类静态代码块  父类静态属性  子类静态代码块  子类静态属性
父类代码块  父类属性 父类构造   子类代码块 子类属性   子类方法

代码块为匿名内部类提供了便利

java中数组的相互赋值  实际上是指针之间的 传递  也就是句柄的传递

当没有明确的初始化数组的值的时候   如果数组中的值是 基本数据类型  则会默认初始化为0 false 
如果是引用数据类型  则会默认初始化为null
       
       
