前面我们在档案介绍中  知道了权限和属性
那么这些属性是记录在硬盘的那个地方? 这里就要特别了解 linux档案系统如何记录档案

因为硬盘可能有一个盘面   也可能有两个盘面    一个圆圈是一个磁道   如果是两个盘面  半径相同的磁道组成了磁柱子
为什么要partion 分区   硬盘的分隔 就是告诉操作系统 我这块硬盘可以存取的区域是从a磁柱  到b磁柱

mbr里面放的是这个分隔区的 起始磁珠与结束磁柱放在

mbr的唯一限制  就是只能记住4个分区   这就是主分区  与扩展分区加起来 只能有4个原因了
如果你预计分割超过4个的话   那么势必要使用3p+1e  一定要为4个  如果是超过了4个分区

如果4个分区没有分完全部空间 那么多余的就会浪费
一个磁头读取的数据是一个sector 如果读取一个10mb  要进行20480次

为了克服效率的低下  就有了逻辑块block的产生了  逻辑区块是在文件系统格式化的时候 为2的倍数  如果block的大小为4k  则读取10mb 需要2560次一个
理论上一个分区是不能有两个文件系统的

superblock 是读取磁道 第一个区块 里面存放元数据  存储的是系统大小  空的 和填满的区块

linux系统中把档案的内容分为两个部分来存储   一个是档案的属性  另一个是档案的内容

inode  记录的数据有  拥有者与群组  存取模式   类型  还有指针pointer的作用  指向的是 这个文件存储在哪个block中
一个inode的大小是128字节
格式化linux   ext2  档案系统   可以使用mke2fs


因为由于innode  table的作用  当一个档案系统格式化以后  也就是一个g的分区 还没使用 就少了16mb的容量
假设一个block 设定为4k    而一个节点 的大致容量在8k 左右
假设分区是一个g   那么1g*1024*1024kb 位101372
而一个节点会占用 128kb  因此  也就是1gb的partion  还没有存储任何数据之前  就少了16mb的容量了

innode节点数量多于block 是没有任何意义的

如果档案数据太过离散  则就可以吧整个partation内的数据复制出来  然后把分区重新格式化  再把数据复制回去即可

dumpe2fs /dev/sda1  可以看出sda1下面的  文件系统信息

innode bitmap 记录那些节点没被使用

block bitmap 记录那些块没被使用
当数据存储到硬盘的时候 分两个步骤

1步骤 是把节点 和block 写入磁盘   2步骤 是吧节点和freeblock 等metadata 传回给superblock
当断电情况产生时  可能只进行了第一个步骤  而第二个步骤没有完成
所以ext2 在加电的时候 会去将meta数据与 实际数据进行比较  浪费时间
而ext3 中加入了日志记录功能

df-k 可以查看 已使用 和未使用的
硬连接  是在同一个文件系统中  对目录下面的文件做一个连接   因此不可以跨文件系统  而且不能对目录做连接  因为 如果对一个目录做了连接 如果
添加了一个文件  则要对文件做连接  这会大大增加复杂度

软连接  是一个新文件  因此会占用inode 与block 
当你新建一个目录的时候   新的目录连接数是2  一个是. 一个是..
fdisk -l 看出磁盘使用情况

从主引导记录的结构可以知道，它仅仅包含一个64个字节的硬盘分区表。
由于每个分区信息需要16个字节，所以对于采用MBR型分区结构的硬盘，最多只能识别4个主要分区（Primary partition）。
操作系统一定要放入  主分区中(而且是活动分区中)

fdisk -l 可以查看所有分区信息

/etc/fstab 

etc/fstab 是开机设定档


/etc/
环境变量在 操作系统中也是非常重要的

rm-df 递归删除是不错


basename  dirname  是取得 目录名和  文件名

cat tac more less 

cat一般是用来看文本文件的

od是用来看执行文件的  也就是二进制文件
档案的三种时间  atime 访问时间  mtime  修改时间   ctime  status  权限或属性被改变的时间

