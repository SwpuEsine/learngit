分为  if  condition
     then 
     else
     end if
     
     case when
     
     在exception 中也是 exception  when others
     
     
     加;的情况   变量赋值要加   begin  end； 表示一个结束  if else end if； 要加 表示一个if的结束
     
     一条sql语句结束后要加
      oracle中的case 语句的选择器 是一个变量或一个返回有效数据类型的函数  选择器不可以是布尔类型
      
      紧跟在case关键字后面的是选择变量或者函数   可以是任何数据类型  但是不可以是布尔类型
      
      在case语句中不指定else 会触发ora-6592异常
      
      普通case语句是检测值 是否一致
      
      搜索case语句仅能用于布尔类型的值   在搜索case语句中  每一个when字句都包含一个表达式
      
      如果检测表达式的值为true 那么相应的子句会执行
      
      当case后面没有表达式的时候   是默认为true  表示搜索case语句
      
      when v_Sal between 1000 and 5000  可以来表示范围
      
      
      
      pl/sql 中循环有四 类   第四类是游标的for循环
      
      loop  endloop  exit  循环  退出 选择 exit  或者exit when  在Loop 中还有CONTINUE WHEN
      
      loop 和end loop  最少执行一次
      while condition
      loop
      end loop;
      
      while循环
      
      for  loop循环分为 数字for循环 和游标for循环
      
      
      for i in [reverse] 1..3
      
      DBMS_OUTPUT.put_line(i)  输出 1 2 3
      
      如果for i in 3..3  则输出一次3
      
      if value>5
       then 
          DBMS_OUTPUT.put_line('value>5');
        else
          NULL;
       end if;
       
       
       在pl/sql中所有的ddl语句都包含了一个隐式提交的事务语句，因此只要这些命令执行，系统就会向数据库提交更改
       
       在pl/sql语句块中不可以直接执行ddl  但是可以通过动态sql 来实现ddl
       
       
       一般创建表是创建 当前登录用户的
       
       如果要创建其他方案   则可以使用create table hr.workcenter{
                                    id  int,
                                    name varchar2(20),
                                    constraint name primary key (id)
                                  }
      
      　　p指精度(precision)，即总位数。默认情况下精度为38。
        
        默认情况下精度和刻度都是可选的   精度默认是38  刻度默认是 在没有指定的情形是84~127。
        小数位的默认值由精度来决定。如果没有指定精度，
        小数位默认为最大的取值区间。如果指定了精度，没有指定小数位。小数位默认为0(即没有小数位)。
        
        
        通常情况下  当前用户对象 是无法创建别的用户的表的   会显示权限不足
        
        可以让管理员通过使用
            GRANT   create ANY  TABLE
                    create ANY  VIEW
                    create ANY  PROCEDURE
                    to scott
         select t.*,t.rowid from TBL_FUN_INF t
         
         查看后可以加锁  解锁 然后操作
         
         
         表空间   一个数据库可以有多个表空间   但是一个表空间只能对应一个数据库
         
         一个表空间可以有多个数据文件   但是一个数据文件只能属于一个表空间
         
         ctrl+e 可以查看历史执行语句
         
         SELECT * FROM V$SQL
         
         create table as select * from system.表名
         
         这样会创建一个表 和system的表名和字段的属性 完全一致  并且含有所有数据   但是约束  如主键 非Null 唯一等不会继承
         
         如果只要字段属性  可以使用  create table as selec * from system.表明 where 1=2
         
         主键约束必须非空   约束  通常分为字段之间的约束   和表之间的约束
         
         一般来说 主键应该是对用户没有意义(一般不建议使用员工卡号等来作为用户的主键)  且由计算机自动生成的  比如使用序列
         
         创建外键约束   外键不一定是主键
         
         
         聚众索引和非聚众索引  聚众索引一定是唯一性索引   唯一性索引不一定是聚众索引  
         
         聚集索引，在索引页里直接存放数据，而非聚集索引在索引页里存放的是索引，这些索引指向专门的数据页的数据。
         
         外键不一定是主键  但是外键必须引用的是主键   外键的作用是为了保证引用完整性
          
         必须一个学号 的一条记录中有一个班级号   这个班级号的作用是可以在班级表中找到唯一的 一条记录  保证一对一的关系
         
         一个关系表事实上是具有共同属性的一类实体的集合。按照集合的定义，集合中元素不能重复
         
         从键也可以知道  一个Key 肯定是一个value  所以外键引用的必须是主键
         
         外键可以引用另一张表的主键或者 唯一键
         
         constraint 约束名  foreign key () reference 表名(字段名)
         
         
         除了主键约束  唯一键约束外  还有check约束
         
         例如create table invoice_check{
         
               invoice_id   NUMBER,
               finvo_total  Number(6,2) check(finvo_total>0 AND invi<=500)
         
         }
         
      
        
      
       检查约束的限制   检查约束不能包含子查询和标量子查询
       不能为视图建立检查约束
       
       
       数据字典表本身不能被直接访问    必须通过数据字典视图来访问数据字典中的信息    系统的数据字典视图以v$ 开头
       
       select * from user_constraints where table_name='TBL_FUN_INF' 
       
       alter table Stu_PkFk_S add constraint PK_S primary key (sno)
       
       语法：alter table 表名 drop constraint 主键约束名
       
       alter table 表名 drop constraint 外键约束名
       
       alter table 表名 add constraint 外键约束名 foreign key(列名) references 引用外键表(列名)
       
       alter table 表明 drop column  列名   可以删除表的列
       
       当drop一个表的时候  如果别的表有引用这张表 则这张表不可删除  而字段之间有应用的话 会删除  会级联删除  设置cascaded
       
       on delete cascade;
       
       索引的好处是相当于一个书签  它会加速数据的检索  但是会增加维护的成本
       
       一张表只能有一个聚众索引  但是可以有多个非聚众索引
       
       oracle不推荐人为的创建唯一性索引   当你在创建表的时候创建了主键约束   或者唯一键约束   oracle会自动在约束列上建立唯一索引
       
       3、 在一个分支节点块中所能容纳的记录行数由数据块大小以及索引键值的长度决定。比如
       
       
       B树索引 一般是两层 或者三层结构   每个节点有两个字段  第一个表示下个节点中的最小键值   第二个表示地址
       
       在叶子节点中  第一个表示值  第二个表示rowid  其中是双向链表
       
       http://blog.csdn.net/zhaohuabing/article/details/1447721
       
       聚众索引 就像拼音  非聚众索引像偏旁部首  
       
       oracle中的单列索引不能插入null值   如果有Null 值则不会利用索引  因为建立索引会排序  默认是升序null值不利于比较操作
       
       对于身份证号这种需要建立b树索引 因为建立需要全表扫描  然后排序  基数大不重复 
       
       而对于基数比较小   比如性别 这些  只需要使用位图索引就可以了
       
       
       
       逻辑碎片是在文件系统里，数据库文件的碎片，这和其他任何文件一样。这在文件系统不能分配给数据库文件连续空间时产生。这会造成磁头从数据库文件读时需要来回移动。SQL Server对此毫不知情，也不能用任何脚本去检查逻辑磁盘碎片。逻辑磁盘碎片可以因下列原因产生：

数据库文件与其它文件（系统文件和其他应用程序文件）放在同个磁盘；
数据库文件以小块大小频繁增长
移除逻辑碎片我们可以使用系统碎片整理工具，但是注意，在进行碎片整理时，我们需要停止SQL Server，不然的话碎片整理工具会跳过数据库文件，因为它正被SQL Server使用。

避免逻辑碎片的最佳方式是:

将数据库文件放在独立的硬盘，与其他应用程序和日志文件分开。
创建新数据库的时候，估计下数据库文件的大小并分配足够的空间避免数据库文件的频繁增长。
指定数据库文件增长选项为大块而不是频繁的小块增长。

http://www.cnblogs.com/woodytu/p/4513562.html
索引碎片的产生 1  是由于文件系统的影响   2 是由于索引文件的逻辑顺序与物理顺序不一致造成的

内部碎片是执行insert  delete  update 的时候产生的碎片

磁盘碎片会影响性能    

删除索引 drop index 索引名

 当前用户需要drop index 权限   其他用户需要drop any index 权限
 
 
       
